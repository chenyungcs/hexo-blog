{"pages":[{"title":"about","text":"","link":"/前端/index.html"}],"posts":[{"title":"如何处理IOS端输入法导致fixed元素显示异常？","text":"手机端网页一个比较常见的交互场景就是输入，输入由输入框和输入法弹窗UI共同完成，为了更好的交互，手机端浏览器一般会自动将输入框滚动到屏幕中央，使用户能看到输入内容。但不同浏览器处理方式并不一样，导致UI多端不统一 描述：点击输入框框，弹出输入法框，按钮可能会被遮住。而在大部分安卓机型中，按钮是正常显示（图三）的 差异分析：ios 通过usb连接mac和ios，可以实现页面调试，通过调试 12document.body.getBoundingClientRect()// _&gt; DOMRect {x: 0, y: -298, width: 320, height: 434, top: -298, …} 可以看出body整体上移了200多个像素，但高度却还是屏幕可视高度。 找到原因了，那么就可以出解决方案了。有什么web api 可以解决吗？有没有较好的解决方案呢？ web api我没有找到，本身这是个别浏览器内核不同实现，我们的业务中，按钮不需要显示在输入框上面，所以问题相对简单了。 123456789// 光标聚焦，文本框回归文档流handleFocus () { this.$refs.footer.style.position = &apos;static&apos;;}// 光标丢失，文本框脱离文档流handleBlur () { this.$refs.footer.style.position = &apos;fixed&apos;;} 这样处理，还能保证，各浏览器显示效果一致。 ps:这样会损失一点点小小的性能（回流） 🤔如果按钮一定要显示到底部？ 由于业务不需要实现，没去实践，只是简单分析下实现 通过js控制按钮位置 判断平台 光标聚焦后，获取document.body.getBoundingClientRect用于计算 设置按钮距离顶部距离 由于键盘弹出有过渡时间，所以这个方法体验可能不是太好 将按钮和固定区域（滚动区域）分为两块123456&lt;div class=&quot;wrapper&quot;&gt; &lt;!-- 高度根据wrapper变 --&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;!-- 固定高度，位于底部 --&gt; &lt;button class=&quot;btn-bottom&quot;&gt;&lt;/button&gt;&lt;/div&gt; 🤔键盘隐藏后，页面下方留白 ios 下，键盘隐藏后，会在页面下方留下（撑开）一片空包区域，滑动屏幕后便会消失，很奇怪。没仔细研究，感觉应该也是浏览器实现问题吧？想到一个hack的解决办法模拟滑动屏幕的动作 123handleBlur () { document.body.scrollBy(0, -1);},","link":"/2019/02/01/如何处理IOS端输入法导致fixed元素显示异常？/"},{"title":"记一次unload相关的问题","text":"一如既往，开发中遇到的问题。 需求：大佬说，我要在用户离开时记录一下。做一个百度的「实时访客」功能SO：我们是单页应用访问每个页面时，发送一个请求，告诉服务器，访问啥页面如果第一次访问，后端返回一个ID作为访问行为的标志onunload事件中发个请求 #14 ，告诉服务器，客户离开了下班走人~~ 好像没这么简单，于是再来一遍 SO 假设：浏览器可能不会正常关闭那就增加一个「异常」状态，如果超过一段时间没关闭那就异常吧，毕竟微信不是我家开的 假设：我们产品运行在厉害的（万恶的）微信浏览器上，会不会出幺蛾子呢？杀千刀的，浏览器内核不同，还好有兼容指南 假设：刷新呢？也会执行onunload好办，记录一下id到storage，如果刷新肯定会再次发「访问请求」，把这个id传给后端 看似一切都好办，其实坑常在。由于操作的特殊性，浏览器的安全策略，会阻止一些操作，例如： 在ios环境下，unload 中执行 localStorage就是不得行storage 有两种：session 和 local，都是基于cookie，两者api都一样，区别就在于：session的生命周期是一次会话；而localStorage，需要手动清除。对于浏览器来说，localStorage会导致内存增加，影响性能，so，我猜，这个用户无感知（意想不到）的操作，ios是不允许的。 于是，尝试session，正好，该特性十分适合这个需求。浏览器会话只会在关闭时结束，所以理所当然，离开时，id也就销毁的，而刷新则还在，十分契合。 unload 靠谱吗？ 之前提到过，ios平台下，unload只在刷新时执行 那beforeUnload呢？ 在MDN上寻觅后，发现pageHide与之同效，与pageHide 对应的api有pageShow 是时候，发挥咱们前端的真实作用了…123456const eventName = $deviceTypeIs(&apos;ios&apos;) ? &apos;pagehide&apos; : &apos;unload&apos;;// 监听刷新window.addEventListener(eventName, (e) =&gt; { /* do */}); 总结 使用 unload 和 pageHide localStorage 和 sessionStorage","link":"/2019/02/01/记一次unload相关的问题/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Web Front","slug":"Web-Front","link":"/tags/Web-Front/"},{"name":"Experience","slug":"Experience","link":"/tags/Experience/"},{"name":"Event","slug":"Event","link":"/tags/Event/"}],"categories":[{"name":"web front","slug":"web-front","link":"/categories/web-front/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"摄影","slug":"前端/摄影","link":"/categories/前端/摄影/"},{"name":"推荐书籍","slug":"前端/摄影/推荐书籍","link":"/categories/前端/摄影/推荐书籍/"}]}