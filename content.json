{"pages":[{"title":"about","text":"","link":"/前端/index.html"}],"posts":[{"title":"safari中window.open 被拦截","text":"safari、以及某些浏览器会被安全拦截。通过异步的方式调用，可以解决 12345678// open 方法返回一个对象：此时打开一个新tabvar windowLink = window.open(&apos;&apos;, &apos;_blank&apos;);// 触发资源下载windowLink.location = openUrl;// 关闭方法windowLink.close();","link":"/2019/02/01/safari中window-open-被拦截/"},{"title":"如何处理IOS端输入法导致fixed元素显示异常？","text":"手机端网页一个比较常见的交互场景就是输入，输入由输入框和输入法弹窗UI共同完成，为了更好的交互，手机端浏览器一般会自动将输入框滚动到屏幕中央，使用户能看到输入内容。但不同浏览器处理方式并不一样，导致UI多端不统一 描述：点击输入框框，弹出输入法框，按钮可能会被遮住。而在大部分安卓机型中，按钮是正常显示（图三）的 差异分析：ios 通过usb连接mac和ios，可以实现页面调试，通过调试 12document.body.getBoundingClientRect()// _&gt; DOMRect {x: 0, y: -298, width: 320, height: 434, top: -298, …} 可以看出body整体上移了200多个像素，但高度却还是屏幕可视高度。 找到原因了，那么就可以出解决方案了。有什么web api 可以解决吗？有没有较好的解决方案呢？ web api我没有找到，本身这是个别浏览器内核不同实现，我们的业务中，按钮不需要显示在输入框上面，所以问题相对简单了。 123456789// 光标聚焦，文本框回归文档流handleFocus () { this.$refs.footer.style.position = &apos;static&apos;;}// 光标丢失，文本框脱离文档流handleBlur () { this.$refs.footer.style.position = &apos;fixed&apos;;} 这样处理，还能保证，各浏览器显示效果一致。 ps:这样会损失一点点小小的性能（回流） 🤔如果按钮一定要显示到底部？ 由于业务不需要实现，没去实践，只是简单分析下实现 通过js控制按钮位置 判断平台 光标聚焦后，获取document.body.getBoundingClientRect用于计算 设置按钮距离顶部距离 由于键盘弹出有过渡时间，所以这个方法体验可能不是太好 将按钮和固定区域（滚动区域）分为两块123456&lt;div class=&quot;wrapper&quot;&gt; &lt;!-- 高度根据wrapper变 --&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;!-- 固定高度，位于底部 --&gt; &lt;button class=&quot;btn-bottom&quot;&gt;&lt;/button&gt;&lt;/div&gt; 🤔键盘隐藏后，页面下方留白 ios 下，键盘隐藏后，会在页面下方留下（撑开）一片空包区域，滑动屏幕后便会消失，很奇怪。没仔细研究，感觉应该也是浏览器实现问题吧？想到一个hack的解决办法模拟滑动屏幕的动作 123handleBlur () { document.body.scrollBy(0, -1);},","link":"/2019/02/01/如何处理IOS端输入法导致fixed元素显示异常？/"},{"title":"一些JavaScript知识点记录","text":"闭包 谈谈数据类型 垃圾回收机制 event loop 数组 正则 喜闻乐见的闭包 函数作用域可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为闭包！ 通常的套路是，面试官会给出一段代码 12345678910for (var i = 0; i &lt; 5; i++) { setTimeout(() =&gt; console.log(i), 0);}// 输出？// 5// 5// 5// 5// 5 面试官：非常好，为什么？小白我：因为没有闭包。面试官（露出慈祥的笑容）：好，将上面代码改成闭包并且解释下闭包。balabala… 1234567891011121314151617181920// 小白我for (var i = 0; i &lt; 5; i++) { (() =&gt;setTimeout(() =&gt; console.log(i), 0))();}// 正确解法// `event loop` 执行顺序，同步代码 &gt; micro task &gt; macro task，所以将`setTimeout`放入闭包内// `for循环`内自执行函数（闭包）声明变量保存i值// 输出`index`变量for (var i = 0; i &lt; 5; i++) { (() =&gt; { var index = i; setTimeout(() =&gt; console.log(index), 0); })();}// es6 解法for (let i = 0; i &lt; 5; i++) { setTimeout(() =&gt; console.log(i), 0);} let 特性 不存在变量提升 暂时性死区 同一作用域不允许重复声明 为什么使用闭包？何时使用？ 保护作用域变量 防止污染全局变量 缺点： 容易内存泄漏 更占用内存 何时用？ 相信如果项目没有使用es6，打开公司的前端源代码，会看到大量如下代码123(function () { /* todo */})(); 上面是一个自执行函数，也是我最早意识到闭包！所以闭包在需要保护作用域变量、实现私有变量时使用！ 关于防止污染全局变量，可以用对象解决，即在全局作用域下声明变量 1234window.GLOBAL = { a: {}, b: {}}; 什么是作用域链？ JavaScript是基于词法作用域的语言：通过阅读包含变量定义在内的数行源码就能知道变量作用域！具体呈现就像树状结构。 总结 这道题其实变相考察应试者的经验！面试官给分：event loop &gt; 异步 &gt; 闭包。当然无论你回答以上三个答案，最终面试官都会继续往下挖，直到他满意或者你答不上！ 谈谈数据类型 包括原始类型、对象类型 原始类型 数字 字符串 布尔 原始值 null undefined 对象类型 除原始类型和原始值之外的类型 常见的有 Array, Object, Function, Date … JavaScript垃圾回收机制 当不再有任何引用指向一个对象，「解释器」就会知道这个对象没用了，然后自动回收它所占用的「内存资源」 内存泄漏 循环引用时，内存资源得不到释放，就会导致内存泄漏！ 123456789101112131415// 内存泄漏window.onload = function (){ var element = document.getElementById(&quot;id&quot;); element.onclick = function (){ alert(element.id); }}// 解决办法window.onload = function (){ var element = document.getElementById(&quot;id&quot;); element.onclick = function (e){ alert(e.target.id); };} 正则数组数组创建数组创建有两种方法 字面量 new Array new Array() 构造函数，接受多个参数。 1234567// 字面量let arrayDemo = [1, 2, 3];// newlet arrayDemo = new Array(1, 2, 3);// 值得注意的是，只传一个参数且为「数字」时，会被认定为初始化「一个数字长度」的数组let arrayDemo = new Array(2); // =&gt; [empty x 2] 方法会改变自身的方法 原始（基本）数组类型是不能改变自身的！比如我们常用的string，charAt substr 这类方法最终也只是返回一个值！同样属于原值类型的还有number boolean push 向数组末尾追加一个或者多个内容，并返回追加后数组长度 1arrayDemo.push(var1, var2); 通常，我们添加一组数据，这组数据很可能是动态的，那能这样吗？ 1arrayDemo.push([1, 2]); // =&gt; [[1,2]] 有两种解决方案： 12345// es6: 利用数组解构arrayDemo.push(...[1, 2])// 利用`apply`特性[].push.apply(arrayDemo, [1, 2]) 使用apply时，应当注意该函数参数个数是「有限制」的。 pop push 的反向方法，删除数组最后一个内容，并返回删除的内容 unshift 在数组前面追加一个或者多个内容，并返回数组长度 shift 删除第一个内容，并返回删除的内容 splice(start, deleteCount, item1, item2, …) 该方法通过删除现有元素和/或添加新元素来更改一个数组的内容。并且返回删除的内容。 在start到start + deleteCount之间添加新内容，直到item*n都插入到数组 12// arrayDemo =&gt; [1, 2, 3]arrayDemo.splice(1, 1, &apos;n&apos;, &apos;n&apos;, &apos;n&apos;); // =&gt; [1, &quot;n&quot;, &quot;n&quot;, &quot;n&quot;, 3] sort(fn) 对数组排序，fn执行length - 1次，并返回排序后的数组 正则匹配返回的数组 属性/元素 说明 示例 input 只读属性，原始字符串 cdbBdbsbz index 只读属性，匹配到的子串在原始字符串中的索引 1 [0] 只读元素，本次匹配到的子串 dbBd [1], …[n] 只读元素，正则表达式中所指定的分组所匹配到的子串，其数量由正则中的分组数量决定，无最大上限 [1]: bB[2]: d 摘自MDN","link":"/2019/02/01/一些JavaScript知识点记录/"},{"title":"一次面试准备","text":"乱七八糟，胡说八道，哈哈 HTMLinput和textarea的区别 从长相到属性描述 textarea由两个标签组成，必须闭合；input 由单个标签组成，不必闭合 input 通过value获取内容；textarea 的内容在两个标签之间，用 .innerText 可以获取 input 有type属性，多种类型完成复杂的交互；textarea无 input 只能单行编辑，且高宽不可拖动；textarea 可以进行多行编辑，高宽可拖动 用div模仿textarea行为 元素上添加contenteditable=&quot;true&quot;属性，使元素可以输入 添加resize: vertical，使元素可以拖动高宽 移动设备忽略将页面中的数字识别为电话号码的方法12&lt;!--手机号码、邮箱--&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no, email=no&quot;/&gt; CSS左右布局 左边定宽、右边自适应，不少于3种方法 float 123456789.layout-wrapper overflow: hidden .layout-left float: left width: 150px .layout-content overflow: block /* do not set width */ /* style here */ flex 12345678.layout-wrapper display: flex .layout-left flex: 1 width: 150px .layout-content flex: 1 /* style here */ position 12345678.layout-wrapper position: relative .layout-left position: absolute width: 150px .layout-content padding-left: 150px /* style here */ BFC、IFC参考详说BFC W3C中的概念 在了解这两个概念前，先解释下 FC = Formatting Contexts 格式化上下文。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 它所表示的不是具体元素，而是这些元素的属性！ 块级盒参与块级格式上下文(BFC),行内级盒参与行级格式上下文(IFC)。 BFC Block Formatting Contexts， 也就是我们常说的「块级格式化上下文」。就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。如何产生BFC？ float 的值不为 none position 的值不为 static 或 relative display 的值为 table-cell、table-caption、inline-block、flex 或inline-flex overflow的值不为 visibility 详见MDN 块格式化上下文 BFC 特性 阻止外边距折叠 两个相连的 div 在垂直上的外边距会发生叠加，BFC可以阻止这类情况发生。 外边距折叠的规律：仅当两个块级元素相邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。 BFC 可以包含浮动元素 BFC 会根据子元素的情况自动适应高度，即使其子元素中包括浮动元素。 常应用于：处理塌陷！ 因为float: left，小明脱离了普通流，所以他的容器没有了高度。而小东使用了BFC，所以有高度！ BFC 阻止元素被浮动元素覆盖 如上所说，浮动元素的同级兄弟元素会尽量占满一行 日常开发中用的较多的左右布局。如果右边宽度写死，且大于剩余宽度，就会换行！ BFC 与 hasLayout 搞不懂 IFC Inline Formatting Contexts 内联格式化上下文，行内级盒参与行级格式上下文(IFC) 影响IFC的属性 font-size line-height height vertical-aligin 还有GFC、FFC 水平居中实现 实现元素的水平居中 inline-block 绝对定位 margin flex 栅格 最早接触栅格化是Bootstrap2， col-xs-3 col-xs-4， Bootstrap把页面一行分成12份 1x12 | 2x6 | 3x4 | 4x3 | 6x2 | 8 | 9 | 12x1。 实现栅格 百分比 flex grid grid 关键字：grid-column grid-row 1px 问题 1px 的问题出现背景是目前越来越高分辨率的显示屏，物理像素和设备独立像素dips不一致，而要保持阅读性，我们通常会在html代码表头加上这段代码 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1.0&quot;&gt; 而这导致的就是，1px 显示为 2px，此时「肉眼所见」的1px，不再是1px。 如何解决 网上的解决方案很多，我比较喜欢阿里的解决方案。动态插入&lt;meta /&gt;根据设备devicePixelRatio决定initial-scale的值！ js1234567891011121314var x = 10;var foo = { x: 20, bar: function () { var x = 30; return this.x; }};console.log( foo.bar(), // =&gt; 20. (foo.bar)(), // =&gt; 20. (foo.bar = foo.bar)(), // =&gt; 10. (foo.bar, foo.bar)() // =&gt; 10.); foo.bar() 函数的上下文在每次调用时，才能确定。对象方法被该对象调用时，其上下文指向该对象。 (foo.bar)() foo.bar 本身就是一个整体，所以上一段代码foo.bar() 等于 (foo.bar)() (foo.bar = foo.bar)() 以及 (foo.bar, foo.bar)() js 中()里面内容为任意表达式，具有「代码块」作用。foo.bar = foo.bar foo.bar, foo.bar 都是表达式，也就是说执行后都会有「返回值」，返回值为最后一个值 12var temp = (foo.bar = foo.bar) // =&gt; f () { ...temp()","link":"/2019/02/01/一次面试准备/"},{"title":"浏览器关闭前向服务器发送一个请求，报告状态","text":"现接到一个需求，收集用户在我司网站的访问行为。 unload 当页面发生跳转、关闭、刷新会先执行beforeUnload，待确认后在执行unload，所以beforeUnload并不能确保一定会关闭 那就在unload事件里处理呗 123window.onunload = function () {document.getElement(&apos;testImg&apos;).src = &apos;http://xxxx.com/collect_page?url=xxxxx&apos;;} 设置&lt;img /&gt;标签地址为接口地址，然后发生请求，然后下班完事了。这么简单？实际情况是：我败了！ balabala….!!!! 网上一顿搜索，都说「同步请求」可解决问题。想象alert是同步执行，可阻止进程，那就试一下吧。 12345window.onunload = function () { var req = new XMLHttpRequest(); req.open(&apos;GET&apos;, &apos;http://127.0.0.1:7002/login?id=1&apos;, false); req.send();} 大功告成，下班走人！！ 哎！等等好像跟alert没半毛钱关系… 继续关注中…其实就是跟alert有关。只不过只有IE可以弹出alert。其他浏览器由于安全策略都不允许弹出 不同浏览器、系统间略有差别，暂时参考 #19","link":"/2019/02/01/浏览器关闭前向服务器发送一个请求，报告状态/"},{"title":"记keyup一个细节 ","text":"需求：在客户端监听keyup事件，实现数据切换 12// 识别按键，分别执行数据切换、数据提交操作window.addEventListener(&apos;keyup&apos;, this.handleKeyUpEvent); 在keyup事件中，会去同步数据同时刷新dom节点。数据刷新不及时、页面感觉卡顿，why?分析按键事件，keydown -&gt; keyup，这是两兄弟，对吧？所以keyup肯定是发生在keydown之后啦，所以页面卡顿… emum，具体延迟如下： 1234567891011window.addEventListener(&apos;keydown&apos;, () =&gt; { console.time(&apos;keyup&apos;);}); window.addEventListener(&apos;keyup&apos;, () =&gt; { console.timeEnd(&apos;keyup&apos;);});// _&gt; keyup: 156.1640625ms// _&gt; keyup: 156.760009765625ms// _&gt; keyup: 47.076904296875ms 手速是响应的关键，并且，我觉得keyup事件，没这么简单，会不会还有「释放资源」这种骚操作？所以keyup处理的事情越简单，越好吧 12// 改为keydown，keydown执行多次，节流？还是另行其法window.addEventListener(&apos;keydown&apos;, this.handleKeyDown); keydown 会执行多次，在我的业务场景中，希望点一下按键，执行一下操作，所以，我希望，keydown执行一次，keyup一次，代码如下： 1234567891011let keyUp = true;window.addEventListener(&apos;keydown&apos;, () =&gt; { if (keyUp) { keyUp = false; // things to do }}); window.addEventListener(&apos;keyup&apos;, () =&gt; { keyUp = true;}); 最后： 记得销毁事件","link":"/2019/02/01/记keyup一个细节/"},{"title":"记一次unload相关的问题","text":"一如既往，开发中遇到的问题。 需求：大佬说，我要在用户离开时记录一下。做一个百度的「实时访客」功能SO：我们是单页应用访问每个页面时，发送一个请求，告诉服务器，访问啥页面如果第一次访问，后端返回一个ID作为访问行为的标志onunload事件中发个请求 #14 ，告诉服务器，客户离开了下班走人~~ 好像没这么简单，于是再来一遍 SO 假设：浏览器可能不会正常关闭那就增加一个「异常」状态，如果超过一段时间没关闭那就异常吧，毕竟微信不是我家开的 假设：我们产品运行在厉害的（万恶的）微信浏览器上，会不会出幺蛾子呢？杀千刀的，浏览器内核不同，还好有兼容指南 假设：刷新呢？也会执行onunload好办，记录一下id到storage，如果刷新肯定会再次发「访问请求」，把这个id传给后端 看似一切都好办，其实坑常在。由于操作的特殊性，浏览器的安全策略，会阻止一些操作，例如： 在ios环境下，unload 中执行 localStorage就是不得行storage 有两种：session 和 local，都是基于cookie，两者api都一样，区别就在于：session的生命周期是一次会话；而localStorage，需要手动清除。对于浏览器来说，localStorage会导致内存增加，影响性能，so，我猜，这个用户无感知（意想不到）的操作，ios是不允许的。 于是，尝试session，正好，该特性十分适合这个需求。浏览器会话只会在关闭时结束，所以理所当然，离开时，id也就销毁的，而刷新则还在，十分契合。 unload 靠谱吗？ 之前提到过，ios平台下，unload只在刷新时执行 那beforeUnload呢？ 在MDN上寻觅后，发现pageHide与之同效，与pageHide 对应的api有pageShow 是时候，发挥咱们前端的真实作用了…123456const eventName = $deviceTypeIs(&apos;ios&apos;) ? &apos;pagehide&apos; : &apos;unload&apos;;// 监听刷新window.addEventListener(eventName, (e) =&gt; { /* do */}); 总结 使用 unload 和 pageHide localStorage 和 sessionStorage","link":"/2019/02/01/记一次unload相关的问题/"},{"title":"调试接口很痛苦有木有，小试一下Mock","text":"开发中，常遇到A要接口、B要接口、C要接口。环境却只有一个，一旦切换，都将导致BC接口访问失败啥的，下面，我准备把Mock 用起来。 安装https://github.com/nuysoft/Mock/wiki/Getting-Started 根据自己项目调整就好了。 html12345&lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;&lt;!-- 主要是进行配置：timeout 目前唯一的配置项 --&gt;&lt;script src=&quot;./js/mock/index.js&quot;&gt;&lt;/script&gt;&lt;!-- 分接口的Mock规则 --&gt;&lt;script src=&quot;./js/mock/MallStatistics.js&quot;&gt;&lt;/script&gt; MallStatistics.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 请求成功的返回格式 */function successBody (body, limit = 0) { return { [`data${limit ? &apos;|&apos; + limit : &apos;&apos;}`]: body, &apos;code&apos;: 0 };}/** * 请求失败的返回格式 */function errorBody (body, code = 1001) { return { &apos;data&apos;: body, &apos;code&apos;: code };}var liveRule = new RegExp(&apos;/mock/mall/live?.+&apos;, &apos;&apos;);/** * 实时访客 */Mock.mock(liveRule, &apos;get&apos;, function ({ body }) { var { limit = 20, offset, date } = JSON.parse(body); // 模拟数据 var data = Mock.mock(successBody( { [`meta|${limit}`]: [{ &apos;access_time&apos;: `${date} @TIME`, // 访问时间 &apos;client_number&apos;: &apos;@INTEGER(10000, 99999)&apos;, // 客户编号 &apos;client_name&apos;: &apos;@CWORD(6,20)&apos;, // 客户名称（店名） &apos;main_account&apos;: &apos;@CNAME&apos;, // 主账号 &apos;phone&apos;: &apos;182@INTEGER(1000, 9999)@INTEGER(1000, 9999)&apos;, // 手机 &apos;dc_name|1&apos;: [&apos;楼兰&apos;, &apos;大燕京&apos;, &apos;你看&apos;, &apos;数据啊&apos;, &apos;&apos;], // 营业部 &apos;place_order|1&apos;: [true, false], // 是否下单 &apos;residence_time&apos;: &apos;@INTEGER(5, 10000)&apos;, // 停留时间？这个是否从access_url中统计（前端处理） &apos;is_active|1&apos;: [true, false], // 是否正在访问 &apos;access_url|1-50&apos;: [{ // 访问记录 &apos;access_time&apos;: &apos;@TIME&apos;, // - 访问时间 &apos;residence_time&apos;: &apos;@INTEGER(5, 10000)&apos;, // - 停留时间 &apos;url&apos;: &apos;http://mall.balabala.cn/#/@NAME&apos; // - url }] }], &apos;total&apos;: `@INTEGER(${limit}, ${limit*10})` } )); data.data.meta = _.sortBy(data.data.meta, &apos;access_time&apos;).reverse(); return data;}); 需要注意的语法规范数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值 1234// 属性名 name// 生成规则 rule// 属性值 value&apos;name|rule&apos;: value 生成规则|当|规则为空时，表示为|0 占位符Mock内置了强大的Random对象。可通过对象调用，也可以通过「占位符」，例如： 1234567891011// 生成一个随机英文名{ &apos;name&apos;: Mock. Random.name()}// 那这样呢？{ &apos;data|10&apos;: [{ &apos;name&apos;: Mock.Random.name() }]} 可见连续生成了10个同样的数据，我们需要随机生成不同的。有两种方法: 12345678910111213141516// 通过function{ &apos;data|10&apos;: [{ &apos;name&apos;: function () { return Mock.Random.name(); } }]}// 通过占位符{ &apos;data|10&apos;: [{ &apos;cname&apos;: &apos;@CNAME&apos;, &apos;englishName&apos;: &apos;@FIRST@MIDDLE@LAST&apos; }]} 可见，通过占位符调用Random里的方法，就是@全大写的方法名对了，你还可以@已有规则，例如： 123456{ &apos;data|10&apos;: [{ &apos;myName&apos;: &apos;@CNAME&apos;, &apos;store&apos;: &apos;@myName的小店&apos; }]} mock(rurl?, rtype?, template|function( options ))方法的使用12rurl -&gt; url规则rtype -&gt; 请求类型 方法很简单，很好使用，只有两点需要注意的。 get请求下，参数也会被视作url的一部分，例如user?id=1，这也是开头我使用正则的原因。👇下面的例子将无法正确匹配 12345678// mock/user// http$.ajax.get(&apos;user/&apos;, { id: 1, name: &apos;李四&apos;}); 请求类型在大多数情况下是不需要的。但，如果你的接口是RESTful风格，加上Type就十分必要的 123DELETE : /userGET: /userPOST: /user timeout 重要性一般，我们的页面一加载，就会请求一波后端接口，受网络影响，会延迟那么一会儿。现在我们使用的Mock会在被调用的时候，马上去生成数据，由于生成数据算法影响 会卡一波。所以，别怪我没提醒你，乖乖的去设置你的timeout。 123Mock.setup({ &apos;timeout&apos;: 500}); 对了，那就顺便记录一下：当生成复杂列表时：超过100条会明显卡顿。 约定好Model 开发前，一定和后端大佬约定好Model，接口地址、参数。 大概就是酱紫😯，总结下 注意语法规则 注意url规则和请求类型 设置timeout 约定Model","link":"/2019/02/01/调试接口很痛苦有木有，小试一下Mock/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"代码片段","slug":"代码片段","link":"/tags/代码片段/"},{"name":"Css","slug":"Css","link":"/tags/Css/"},{"name":"Event","slug":"Event","link":"/tags/Event/"},{"name":"工具","slug":"工具","link":"/tags/工具/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"}]}